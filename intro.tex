%!TEX root = gutter+stars.tex
\chapter{Introduction}

Dispite common believe, software engineers do not spend most time writing code. An approximate 50--80\% of development time is spend on code navigation and understanding \cite{a,b,c,d}. This may include reading of local source  source code and documentation, searching the internet for tutorials and code examples, but als seeking the help of another developer. User studies have found that developers use four kinds of cognitive clues for \codenavigation \cite{a,b,c}: lexical clues, social clues, episodic clues and spatial clues. 

Examples of \codenavigation clues are 
	(a) recalling a name or having a guess about the answer's name, or
	(b) knowing a person with expertise or a place on the internet where people share their expertise, or 
	(c) an episodic memory about a past encounter with the answer, for example about having seen it on a mailing list, and 
	(d) sometimes even a spatial clues, like recalling that a given functionality is located at the end of that one specific source text file. 

Tool support for following-up upon these clues, however, is typically limited to text file processing or hyperlinking of code elements at best. In our research, we explore how development tools can support the cognitive clues that software engineers use for \codenavigation. In interviews with professional software engineers, we looked at how developers find answers to technical questions in order to learn about \codenavigation strategies. We found that finding an answer typically falls apart in to parts, in a first and hard part developers struggle to turn a fuzzy textual clue, or just as often a social or episodical clues, into a concerete textual clue that they can eventually use in the second part to locate the answer in the local documentation or on the internet. Also we identified promising potential for the use spatial clues. 

A key contribution of our work is \emph{Software Cartography}, a novel cartographic visualization of software systems that is supposed to support code orientation by on-screen spatial clues. Code maps, as well call them, are a stable and spatial representation of software system based on lexical information found in the system's source code. Code maps can be used by both individual developers and or shared by a team. We evaluated our approach in a qualitative user study, with both professional and student users, and found that it is most helpful for exploring search results and call hierarchies.

\section{Types of Code Navigation}

In the context of this work, we are interested in better supporting software engineers when they are facing a technical question that is related to source code. We introduce the term \emph{\codenavigation{}} in order to refer to all programming activities that have in common that software engineers do need to find an answer to a technical question that is related to source code. Code orientation is thus am umbrella term of code navigation and code understanding. 

In the following we categorize \codenavigation according to the kind of cognitive clues being followed-up (lexical clues, social clues, episodic clues and spatial clues) and characterize \navigation tasks according to their aim (refind, discovery and learning) and reach (ranging from current working set to the entire internet).

In interviews with developers we found the way from a technical question to an answer is typically split in two parts: the first and hard part is boiling the often fuzzy problem description down to a single lexical clue, which in the second part is used to query documentation, tutorials and mailing list for concrete help. Current tool support for \codenavigation is often limited to \navigation by lexical clues. The above behavior might thus be an artifact of current tool support, \ie developers aim to find a lexical clue first because they are most easy to follow up, or it might not. In either case, developers do need better tool support to follow-up on social, episodic and spatial clues.
	
\subsection*{Aim and Reach of Code Orientation}
	
The aim of a code orientation task can be threefold. It can be about refinding a given piece of code or functionality that developers have encountered or heard of in the past. It can be about discovering a piece of code that you know must exist, by searching you local code repository or the internet for code examples. Or, it can be about learning how to implement a certain piece of code, by talking to people with expertise, by looking reading a book, or by finding advice on a mailing list or a blog. 

The reach of a code orientation ranges from the current working set to the entire internet. The current working set can a single method or all open files. The local codebase can be the current project and the entire codebase of a developer's company, but also includes all local documentation and learning sources. Eventually the ultimate reach is accessing the internet, which offers two kind of codebases. On the one hand there are source code repositories that only contain source code, on the other hand, there is an amazing amount of code examples that are contained in blog posts and website and discussion forums. The latter are a most useful for code orientation because they are selected examples, the authors of the embedding content typically selected these examples for their usefulness for learning and copy-pasting. When going from a local to a global reach, the nature of information sources changes. Local information sources are typically limited and homogenous, authored by a small group of people with known expertise and known trustworthiness. More global information sources are typically unlimited and heterogenous, authored by people with unknown expertise and unknown trustworthiness.

Refind tasks are typically targeted at the local codebase, which with the developers are familiar, whereas discovery and learning tasks are typically targeted at the internet. But it is just as likely that parts of the local code based are unknown to developers and they thus target a discovery tasks locally. Or it can be that developers recall that they've read about the answer on the internet and they thus target a refind task globally.
%Also there is a difference in finding code and finding functionality, like if a developer has never seen some piece of source code it is maybe easier to recall the person that has told him about it rather than recalling the source code's name. And just the same with the forward reaching tasks, where often copy-pasting an example is preferred over learning for pragmatic cost considerations.



%- Maybe you recall the song that played on the webradio, so you look that up ...
%- You can use one kind of information as a proxy for other information, so you can you use social and temporal information as a proxy for dependency information (like Tom Zimmermanns work on recommending other locations to update).
%- Photographic memory.
%- The clues have to be turned into actions.
%- How many (inter)actions do you have to do to follow up one clue.
%- Non-conventional questions that people ask themselves but had no tool to answer them before.
%- Two hard problems in CS, caching and naming.

%- JExample generates 'Examples that are worth to be found' .. JExample makes exampels more relevant and more applicable ...
%- Erwann: information can come right from the source code (lexical clues) and can come from somebody else (social clues) from temporal memory or version control system (temporal ones) ...
%- Clues are not about the sources of information, but about the way developers navigate about how they cognitively work when they follow.

	
%- All these tools help you to follow up, some more complex clues and unconventional information. It is not that any of these tools addresses a very specific task? Erwann thinks yes it does.
%- I want to help developers, working with code, in particular wrt navigation and understanding, and learning about code.  These clues can be  (ii)  or (iii) it could be temporal or episodic, having a memory from the past that could lead you to an answer, that you've seen it last year (or recall the song that played on the radio) or (iv) 
%- maybe in some years we can add here location based clues, like I've written that code on the train. And in the source of JUnit Kent Beck found it so cool that he added "was written on HŸtte at 1200 mUm"
%- and sometime people follow up some very underdeveloped spatial clues. So we know they follow up these clues so we need better tool support and not have to be force to use lexical proxies, you should not be forced to recall the name, but be able to directly work social information when following up a social clues.
%- With spatial information we have this even more special situation that we possible first have to create a space for space.
%- Is there one space to rule them all? or different spaces for different tasks. Codemap that provides one space but still have IDE so onscreen is split, Codecanvas does the same but put the source code on it such that the space become the only onscreen space, the space should be contextually created.
%- The thesis emerged from my work, is that in order to support developers with code navigation we need to build better tools that address the cognitive clues that are used by developers, in particular (in addition to lexical clues) to support navigation by social clues by temporal clues and by spatial clues, and since software has no ...
%- lexical clues are present as identifier names and in comments, social clues are also there we know how has written software and mailinglists etc so people are also there as entity, and also temporal information is tere we have versioning systems that make snapshots of a system in time, but spatial is more difficult ...
%- it somehow maps to the structure of software, which you can extract from source code, but very often spatial is more on a conceptual level and people even use spatial terms on the very level of the arrangement of the UI on screen. So we have three spatial dimensions, structural, conceptual and on screen. So the spatial clues have the least support, so we gotta create a space of software of onscreen to support spatial navigation by developers. 
%- Since software lacks we need to create a spatial view to address the on-screen spatial clues. To create a cartographic representation of other non-spatial properties of the system (like temporal, social and lexical ones) and give them a spatial representation os people can use this forth kind of navigation clues that are actually used. When you talk with developers how they find answers to technical questions related to source code they will tell you sometime they recall a method is at the end of this file, which is onscreen spatial representation. Lemme browser the packages it us up there, down there. And they will use this in the same sentence as some spatial representation that is related to package structure. We have to fix this also up there in the business layer, it as down there in this file, we have to fix this up there it is down there in this file. 

\subsection*{Orientation by Lexical Clues}

% Importance
Lexical clues are very important for code navigation. They are by far the most common clue used by software engineers for \codenavigation. 
% Examples
Examples of lexical clues are the name of an identifier used to refind some code, or a keyword used to search the web for documentation or code examples. 

% Assumption
Developers do rely on lexical clues because they assume that names are meaningful, that there is a meaning to names and that names have been meaningfully chosen. 
% Kind of information?
Lexical clues are typically pointers to lexical information that is present as identifier names and in comments. However, lexical information is not limited to source code but also present in the content of an email, a bug report or a web page. For example, following-up a lexical clue might guide the developer to a wikipedia page that contains the algorithm he's looking for. 

% Tool support and hint a need that we address later on?
Simple keyword search and regular expressions are of great help to follow-up on a lexical clue. However, a major problem with lexical clues is that developers to have to make a guess about how other people name things. Using information retrieval and natural language processing can help to address that problem. 

% Lexical clues are very important for search. Often process that you first need to find lexical clue so you know here do gonna search, for example name of a class or method

\subsection*{Orientation by Social Clues}

% Importance
Social clues are often not considered part of software comprehension, yet they are most powerful for discovery and learning. 
% Examples
Examples of social clues can be asking another person for help, or posting a question to a discussion board on the web where experts gather and share their expertise. 

% Assumption 
Developers do rely on social clues because they assume that other people do have expertise, that these other people do have more or different expertise so they can be of help to find answers. 
% Kind of information?
Social clues are typically pointers to other persons from the developer's personal network, either a co-worker or a friend. However, social clues are not limited to the personal network but can also appear in the form of mailing lists and other expert groups that are ready to share their expertise online on the internet.

% Tool support and hint a need that we address later on?
Support for code orientation by social clues is typically not present in development tools, thus the current state of the art is that developer have to recall the name of a person with expertise. This basically boils down to a lexical clue that has to be used a proxy for the actual social clue that developer does want to follow-up. Using techniques and ideas drawn from social media as found on the web can help to address that problem.

\subsection*{Orientation by Episodic Clues}

% Importance
Episodic clues are most helpful to refind source code that has been written or used in the past, since as humans we have strong episodic memories. 
% Examples
Episodic clues are typically tied to personal memory, as for example in recalling the first-hand experience of a conference talk or a pair programming session. 

% Assumption 
Developers do rely on episodic clues because humans do have strong episodic memory and thus their guess about the past is more correct than their current knowledge. This works is because as humans our episodic memory works way better than our structural memory, typically developers do recall ``that'' they knew the answer before but not ``what'' the answer exactly constituted of.  

% Kind of information?
Episodic clues are typically pointers to past interaction with books, mailing lists and other people, but may also be pointers to past snapshots of the current or a related software system. 
% Tool support and hint a need that we address later on?
Support for code orientation by episodic clues in development tools is typically not present. Information that could be used to follow-up an episodic clue is typically stored in external databases, such as version control repositories and mailing list archives, and thus typically not integrated with development tools. Also it is known that visualizations are a powerful means to evoke episodic memories. Using data mining techniques and embedding the results as visualizations in the IDE can help to fill that gap.

%- or you know ''we had this bug a year ago'' or you know ''oh we need to sort a list, we've done this in this project'' ... episodic memory ... or you recall who've told you about it ... 
%- Episodic memory ... recall that they've solved it ... or that they've seen the solution on a mailing list ... learning by lurking ... grown your own folksonomy ... collect your own anecdotes
%- Chronia: ownership map shows how contributers to a software system worked together ... devs get excited ... ''see here we worked together'' .. even better than a holiday photo album.

\subsection*{Orientation by Spatial Clues}

% Importance
Spatial clues can help to reduce the cognitive load of orientation of an hyperlinked document space, such as software systems. 
% Examples
% Kind of information?
Spatial clues can be of three kinds, either they are structural or conceptual as in recalling which class or architectural layer some functionality belongs to, or they are true spatial clues as in recalling the on-screen or within-text-file position of a given function.

% Assumption 
Developers do rely on spatial clues works because as humans they have strong spatial capabilities. The spatial capabilities of our brain is really impressive, it has been found that developers do form a spatially meaningful internal mental model of a software system even though the external model of the software system has no inherent spatial properties by itself. 

% Tool support and hint a need that we address later on?
Current support for code orientation by spatial clues in development tools is \adhoc at best, the systems is presented as a tree view of alphabetically ordered files and inside a file the source is linearized as an unordered text file. While this might accidentally help to refind some code by a spatial clue, support for the discovery of yet unknown source code by spatial clues is limited to structural clues. Providing developers with a cartographic on-screen visualization, so they can use spatial clues for code orientation, may help address this problem.

%- Change on database propagates to business layer, UI layer ... you know where do go spatially, the space is given by space of software, in other case the space is given by layout of IDE, or given by storage format or persistence format, you know it is there in that text file or on that folder, or in smalltalk open in that window.
%- Codemap: if you observe which clues devs use to refer to code, you'll find all four, but if you look at tool support, you find lexical supported by tools, and temporal only in external tools, and social clues are also not supported, you gonna recall the name of person (ie using the lexical clue of the name as a proxy for the social connection) and spatial is not supported at all, we got the IDE layouted without care about spatial thinking ... code bubbles, code map, and code canvas are about the first systems to take care of this ... 
%- If you ask people to draw maps of their software systems ... as Grady Booch does ... and they always draw an architecture with spatial structural ... so the spatial structure is in their thinking but not in the IDE and even not in the software ...
%- So this why codemap is so interesting because it takes the lexical information and give it a spatial structure in the hope to fill the gap when devs are stuck with lexical clues or social/temporal
%- Spatial clues "somewhere at the end of this file"
%- Structural and spatial is often perceived in the same way, developers tend to use spatial terminology to refer to layers and architectural components.
% - To create a space of software that is visualized on screen, so that people can start using that one to navigate in source code.
%- Erwann: the mental model part?
%- To provide them with a space that will become / should reflect their spatial model...
%- Erwann: if the notion of mental model can be used for all clues ... the other tools gravitate around this spatial mental model.

\section{Thesis Statement}

We state our thesis as follows

\begin{quote}
To support code navigation and code understanding, we need development tools that provide first-class support for the cognitive clues that developers use for code orientation. In particular, we need better tool support for social clues and episodic clues. And third, because software has no inherent spatiality, we need to establish a stable and shared cartographic representation of software systems in order to facilitate code orientation by on-screen spatial clues.
\end{quote}

\section{Contributions}

\section{Software Cartography in a Nutshell}

%In this work, we present the following contributions that explore the use of orientation clues for tool building. Each of these contributions has been published as one or more peer-reviewed paper at an international venue or in an international journal.  
%- Information retrieval to make more interesting things with lexical clues.
%- Evoclouds combine lexical with temporal information.
%- Work by Dominique Matter where we go and mine all the date from the temporal repository and mine the the vocabulary from the contribution of the developers, so we have a new tool that models the expertise of the developers so that now when you have a bug report the system can recommend to you the person. You can turn now a fuzzy textual clue into a social thing.
%- So we asses the credibility of search results solely based on the social network of the authors. This is the way developers have been found to asses the trustworthiness of code, since when you copy code from the internet you do so because you do not want to make the effort of technically understanding it so you look at its author's credibility to make an assessment of trustworthiness.
%- So we have the Chronia tool that has a timeline of the project, and you have a timeline of each file and you see the collaboration patterns. When you show this to developers the go crazy, with this visualization the episodic memory is brought back. You can learn about team members.

\begin{itemize}
\item Software Clustering \cite{Kuhn07a,Kuhn05a,Lung05a}
\item  Feature Classification \cite{Kuhn06c,Kuhn05b}
\item  Software Summarization \cite{Kuhn09a}
\item  Spatial Representation \cite{Kuhn10c,Kuhn10b,Duca06c,Kuhn08a}
\item  Ownership Map \cite{Girb05a}
\item  Bug-Report Triage \cite{Matt09a}
\item  Credibility in Code Search \cite{Gysi10b}
\end{itemize}

%%%

%Acquiring knowledge about a software system is one of the main activities in software reengineering, it is estimated that up to 60 percent of software maintenance is spent on comprehension \cite{Abra04a}. This is because a lot of knowledge about the software system and its associated business domain is not captured in an explicit form. Most approaches that have been developed focus on program structure \cite{Duca05b} or on external documentation \cite{Maar91a,Anto02b}. However, there is another fundamental source of information: the developer knowledge contained in identifier names and source code comments.
%
%{\small\begin{quotation}\emph{The informal linguistic information that the software engineer deals with is not simply supplemental information that can
%be ignored because automated tools do not use it. Rather, this information is fundamental. [\ldots] If we are to use this informal information in design recovery tools, we must propose a form for it, suggest how that form relates to the formal information captured in program source code or in formal specifications, and propose a set of operations on these structures that implements the design recovery process} \cite{Bigg89c}.
%\end{quotation}}
%
%Languages are a means of communication, and programming languages are no different. Source code contains two levels of communication: human-machine communication through program instructions, and human to human communications through names of identifiers and comments. Let us consider a small code example:
%
%When we strip away all identifiers and comments, from the machine point of view the functionality remains the same, but for a human reader the meaning is obfuscated and almost impossible to figure out. In our example, retaining formal information only yields:
%
%When we keep only the informal information, the purpose of the code is still recognizable. In our example, retaining only the naming yields:
%
%is morning hours minutes seconds is date hours minutes
%seconds invalid time value hours 12 minutes 60 seconds 60

\section{Outline}

The dissertation is structured as follows

\begin{enumerate}
% --> related.tex
\item[\autoref{the chapter on related work}] discusses related work of this thesis. We present various user studies and solutions to code orientation and analyse the short comings in the context of each orientation clue.
% --> codemap.tex
\item[\autoref{the chapter on codemap}] we introduce \emph{Software Cartography} as approach to establish a cartographic visualization that facilitates spatial code orientation by individuals or teams. The approach is implemented in the \textsc{Codemap} tool.
\item[\autoref{the chapter on the codemap user study}] reports on a qualitative user study that evaluates the prototype implementation of the Software Cartography approach presented above.
\item[\autoref{the chapter on the MSR user study}] presents a user study that looked at how developers find answers to technical questions and discusses code orientation by cognitive clues.
% --> gutter+stars.tex
\item[\autoref{the chapter on lexical clues}] presents an approach to cluster and summarize software systems using lexical information found in source code. The approach is implemented in the \textsc{Hapax} tool. 
\item[\autoref{the chapter on LogLR}] presents an approach that uses lexical information found in source code to summarize whole systems, parts thereof, or even the system's entire evolution. The approach is implemented in the \textsc{EvoClouds} tool.
\item[\autoref{the chapter on chronia}] presents an approach to address the episodic memory of developers by providing them with a visualization that tells the story of the team collaboration as recorded by the version control system. The approach is implemented in the \textsc{Chronia} tool.
\item[\autoref{the chapter on bug reports}] presents an approach that use lexical information found in contributions that developers shared with open source systems to build a recommendation model for bug repots. The approach is implemented  in the \textsc{Devlect} tool.
\item[\autoref{the chapter on codesearch}] presents an approach that uses cross-project collaboration of developers in open source projects to model the credibility of code search results. The approach is implemented in the \textsc{Bender} tool.
\item[\autoref{the conclusion}] concludes the dissertation and outlines future work.
\end{enumerate}


%%%%%%%%%%%%

